# 底层结构

> unordered系列的关联式容器之所以效率比较高，是因为其底层使用了哈希结构。

## 哈希概念

顺序结构以及平衡树中，元素关键码与其存储位置之间没有对应的关系，因此在查找一个元素时，必须要经过关键码的多次比较。顺序查找时间复杂度为O(N)，平衡树中为树的高度，即O($log_2 N$)，搜索的效率取决于搜索过程中元素的比较次数。

理想的搜索方法：可以不经过任何比较，一次直接从表中得到要搜索的元素。如果构造一种存储结构，通过某种函数(hashFunc)使元素的存储位置与它的关键码之间能够建立一一映射的关系，那么在查找时通过该函数可以很快找到该元素。

当向该结构中：

- 插入元素
 根据待插入元素的关键码，以此函数计算出该元素的存储位置并按此位置进行存放
- 搜索元素
 对元素的关键码进行同样的计算，把求得的函数值当做元素的存储位置，在结构中按此位置取元素比较，若关键码相等，则搜索成功

该方式即为哈希(散列)方法，哈希方法中使用的转换函数称为哈希(散列)函数，构造出来的结构称为哈希表(Hash Table)(或者称散列表)

## 哈希冲突

对于两个数据元素的关键字$k_i$和 $k_j$(i != j)，有$k_i$ != $k_j$，但有：Hash($k_i$) == Hash($k_j$)，即：不同关键字通过相同哈希哈数计算出相同的哈希地址，该种现象称为哈希冲突或哈希碰撞。

> 把具有不同关键码而具有相同哈希地址的数据元素称为“同义词”。

## 哈希函数

引起哈希冲突的一个原因可能是：
哈希函数设计不够合理。

### 哈希函数设计原则

- 哈希函数的定义域必须包括需要存储的全部关键码，而如果散列表允许有m个地址时，其值域必须在0到m-1之间
- 哈希函数计算出来的地址能均匀分布在整个空间中
- 哈希函数应该比较简单

### 常见的哈希函数（常见）

#### 直接定址法

取关键字的某个线性函数为散列地址：``Hash（Key）= A * Key + B``
优点：简单、均匀
缺点：需要事先知道关键字的分布情况
使用场景：适合查找比较小且连续的情况

#### 除留余数法

设散列表中允许的地址数为m，取一个不大于m，但最接近或者等于m的==质数==p作为除数， 按照哈希函数：`Hash(key) = key % p(p<=m)`,将关键码转换成哈希地址

## 哈希冲突解决

解决哈希冲突两种常见的方法是：闭散列和开散列

### 闭散列

闭散列：也叫开放定址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到冲突位置中的“下一个” 空位置中去。那如何寻找下一个空位置呢？

#### 线性探测

线性探测：从发生冲突的位置开始，依次向后探测，直到寻找到下一个空位置为止。

- 插入
 	- 通过哈希函数获取带插入元素在哈希表中的位置
 	- 如果该位置中没有元素则直接插入新元素，如果该位置中有元素发生哈希冲突，使用线性探测找到下一个空位置，插入新元素
 
- 删除
 	- 采用闭散列式处理哈希冲突时，不能随便物理删除哈希表中已有的元素，若直接删除元素会影响其他元素的搜索。因此线性探测采用标记的伪删除法来删除一个元素。

#### 线性探测的实现

##### 枚举类型

```c++
// 用一个枚举类型 给哈希表的每个空间给个标记

// EMPTY 表示此位置为空
// EXIST 表示此位置已经有元素了
// DELETE 表示元素已经删除

enmu State {
 EMPTY,  
 EXIST,
 DELETE
};
```

- **功能**: 此枚举类型用于标记哈希表桶的状态
 	- `EMPTY` : 桶为空，为被使用
 	- `EXIST`  : 桶中有有效元素
 	- `DELETE` : 桶中的元素已被删除，但是该位置仍保留（避免影响插入时的探测）

##### 元素结构体`elem`

```cpp
struct Elem
{
 pair<K,V> _val // 键值对
 State _state  // 哈希表桶状态
}
```

**功能：** 哈希表的每个桶存储一个键值对。然后`_state` 用来维护桶的状态

- `_val`：存储键值对（`pair<K, V>`）。
- `_state`：标记当前桶的状态（`EMPTY`、`EXIST`、`DELETE`）。

> 🐨 知识回顾：pair 是标准模库（stl) 的一种模板类 用于表示键值对 或者是 2 个，它定义在 `<utility>` 头文件中。
> pair 的基本用法：
>    pair 有以下特点：
>     1. 存储 2 个值：
>      1. 可以存储 2 个不同类型的值，分别通过`first`和`second` 成员变量访问
>     2. 灵活性：
>      1. 适用于任何数据类型，键`first` 和 值`second` 可以是不同的类型
>  定义和初始化：
>   pair<K,V> pairvar;   // 定义
>   pair<K,V> pairvar(key,value); // 初始化
>   `k`,`v`分别表示键和值的类型
>  访问成员：
>   pairvar.first; // 访问键
>   pairvar.second; // 访问值

##### 哈希表类模板`hashtable`

```c++
template<class K, class V>
class HashTable
{
 //......
};
```

- 泛型设计：使用模板实现，可处理任意键（`key`) 和 值（`value`)类型。
- 成员变量：
 	- `_ht` : 底层存储的动态数组(`vector<Elem>` )，用于存储桶
 	- `_size` : 表示当前哈希表中，有效元素的数量。

> 在代码中，`vector<Elem>` 用于表示哈希表的底层存储结构。这里的 `vector` 是一个动态数组，允许存储任意类型的对象，包括用户自定义类型（如 `Elem`）。

##### 构造函数

```c++
HashTable(size_t capacity = 3)
: _ht(capacity)
, _size(0)
{
 for (size_t i = 0, i < capacity; ++i)
 {
  _ht[i]._state = EMPTY;
 }
}
```

**功能：** 初始化哈希表

- 设置底层动态数组`_ht` 的初始容量为 `capacity` 这里是 3
- 初始化所有桶的状态为`EMPTY` 。表示桶为空。

##### 插入方法

```c++
bool Insert(const pair<K,V> &val)
{
 size_t hashAddr = HashFunc(key);
 // 线性探测解决哈希冲突
 while (_ht[hashAddr]._state != EMPTY)
 {
  if (_ht[hashAddr]._state == EXIST 
   && _ht[hashAaddr]._val.first == key)
   {
    return false; // 已经存在相同的键值对
   }
   
  hashAddr++;

  if (hashAddr == _ht.capacity())
  {
   hashAddr = 0; // 循环到数组开头
  }  
 }

 // 插入元素
 _ht[hashAddr]._state = EXIST;
 _ht[hashAddr]._val = val;
 _size++;
 return true;
}
```

**功能**：插入键值对到哈希表。

- 使用哈希函数 `HashFunc` 计算键的哈希地址。
- 使用线性探测法解决哈希冲突：
 	- 如果当前桶状态为 `EXIST` 且键相同，返回 `false`（键已存在）。  
 	- 否则，继续线性探测下个桶（溢出时从头开始）。
- 插入时将桶状态设置为 `EXIST`，并增加元素计数。

> **为什么使用 `const pair<K, V> &val`？**
在 `Insert` 函数中，参数 `const pair<K, V> &val` 使用了引用（`&`）和 `const`，原因如下：                                                                                                                                                       - **引用传递**：通过引用传递参数可以避免复制整个 `pair` 对象，==提高效率==，尤其是当 `pair` 的元素类型较大时。                                                                                                                - **`const` 修饰**：确保传递进来的 `pair` 对象在函数内部不会被修改，符合函数的语义（插入操作不需要修改传入的 `pair`）

##### 查找方法`find`

```c++
int Find(const K &key)
{
 size_t hashAddr = HashFunc(key);
 while (_ht.[hashAddr]._state != EMPTY)
 {
  if (_ht.[hashAddr]._state == EXIST 
   && _ht.[hashAddr]._val.first == key)
   {
   return hashAddr; 
   }
   hashAddr++;
 }
 return -1; // 未找到元素
}
```

**功能**：查找键对应的哈希地址。

- 使用哈希函数计算初始地址。
- 线性探测，找到状态为 `EXIST` 且键匹配的桶。
- 返回桶的索引或 `-1` 表示未找到。

##### 删除方法`Erase`

```c++
bool Erase(const K  &key)
{
 int index = Find(key);
 if (-1 != index) 
 {
  _ht[index]._state = DELETE; //标记为已删除
  _size--;
  return true; 
 }
 return false;
}
```

**功能**：删除键对应的元素。

- 调用 `Find` 确定元素索引。
- 将桶状态设置为 `DELETE`，并减少元素计数。
- 返回 `true` 表示删除成功，`false` 表示未找到。

 **`if (-1 != index)` 的逻辑：**

- 该语句用于判断 `Find` 是否成功找到了元素。
- 如果 `Find` 返回的索引不是 `-1`，说明找到了对应的键值对，可以进行删除操作（标记为 `DELETE`）。
- 如果返回 `-1`，说明未找到，直接返回 `false`。

```c++
// 在这里，我们假如实现的哈希表中元素唯一，即：key 值相同的元素我们不再进行插入

// 为了实现简单，此哈希表中我们将比较直接与元素绑定在一起





```

#### 二次探测

### 开散列
