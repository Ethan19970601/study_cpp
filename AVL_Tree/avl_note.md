
# 🏷️ AVL树的概念

AVL树是一种自平衡二叉搜索树，由苏联计算机科学家阿迪·加莫夫（Adelson-Velsky）和伊万·兰斯科伊（Landis）在1962年共同发明。AVL是他们姓氏的首字母缩写。

AVL树的主要特点是：

1. **二叉搜索树**：每个节点的左子树只包含小于该节点的键，右子树只包含大于该节点的键。

2. **自平衡**：通过在插入和删除操作后进行旋转操作来保持树的平衡。旋转操作包括左旋、右旋、左右旋和右左旋。

3. **平衡因子**：每个节点都有一个平衡因子，定义为左子树的高度减去右子树的高度。在AVL树中，任何节点的平衡因子只能是-1、0或1。

4. **旋转操作**：
   - **单旋转**：包括左旋（LL旋转）和右旋（RR旋转）。
   - **双旋转**：包括左右旋（LR旋转）和右左旋（RL旋转）。

5. **时间复杂度**：在AVL树中，插入、删除和查找操作的时间复杂度都是O(log n)，其中n是树中节点的数量。

6. **应用场景**：由于AVL树的高度平衡，它在需要频繁进行查找、插入和删除操作的应用中非常有用，例如数据库索引、字典实现等。

AVL树的自平衡特性确保了树的高度不会变得过大，从而避免了退化成链表的情况，这使得AVL树在处理大量数据时非常高效。

## 📌 搜索二叉树存在的问题

### ✏️ 搜查二叉树知识回顾

搜索二叉树，也称为二叉搜索树或二叉排序树，是一种特殊的二叉树，具有以下性质：

1. **二叉树**：它是一个二叉树，即每个节点最多有两个子节点，通常左子节点称为左孩子，右子节点称为右孩子。

2. **节点值**：每个节点都有一个键值（Key），且每个节点的键值是唯一的。

3. **排序性质**：对于树中的任意节点，其左子树中的所有节点的键值都小于该节点的键值，其右子树中的所有节点的键值都大于或等于该节点的键值。

4. **递归性质**：搜索二叉树的左子树和右子树也分别是一个搜索二叉树。

5. **平衡性**：在最理想的情况下，搜索二叉树是完全平衡的，即每个节点的左右子树的高度差为1，这样可以保证树的高度最小，从而使得查找、插入和删除操作的时间复杂度为O(log n)。但在最坏的情况下，如果树完全不平衡，退化成链表，那么这些操作的时间复杂度会退化到O(n)。

6. **操作**：搜索二叉树支持的主要操作包括查找、插入和删除节点。这些操作的时间复杂度依赖于树的高度。

7. **应用**：搜索二叉树常用于实现数据库索引、字典、符号表等数据结构，因为它们可以提供快速的查找、插入和删除操作。

### ✏️ 搜索二叉树的问题

#### ❓搜索二叉树的平衡问题

搜索二叉树,它允许我们快速地插入、查找和删除元素。但是，它的一个潜在问题就是可能会变得不平衡。这里的“不平衡”是指树的形状变得非常“瘦高”，就像一条链表一样。

#### ❓为什么会变成链表

想象一下，如果我们有一个空的搜索二叉树，然后我们开始插入一系列已经排序好的数字，比如1, 2, 3, 4, 5。在这种情况下，每次插入的数字都会比前一个数字大，所以它们都会被插入到当前节点的右子树中。这样，树的形状就会变成一条链表，每个节点都只有一个右孩子，没有左孩子。

#### 💡树的高度和操作时间复杂度

在理想的搜索二叉树中，树的高度应该是O(log n)，其中n是树中节点的数量。这是因为在平衡的树中，每个节点都有左右子树，所以查找任何节点都只需要遍历树的高度。但是，如果树变成了一条链表，那么树的高度就变成了n，因为我们需要遍历所有的节点才能找到目标节点。

- **查找操作**：在平衡的搜索二叉树中，查找一个节点的时间复杂度是O(log n)。但是，如果树变成了链表，查找一个节点的时间复杂度就变成了O(n)，因为我们需要遍历所有的节点。

- **插入操作**：在平衡的搜索二叉树中，插入一个新节点的时间复杂度也是O(log n)。但是，如果树变成了链表，插入一个新节点的时间复杂度就变成了O(n)，因为我们需要遍历所有的节点才能找到插入的位置。

- **删除操作**：在平衡的搜索二叉树中，删除一个节点的时间复杂度是O(log n)。但是，如果树变成了链表，删除一个节点的时间复杂度就变成了O(n)，因为我们需要遍历所有的节点才能找到要删除的节点。

#### 总结

所以，搜索二叉树的一个潜在问题就是它可能会变得不平衡，导致树的高度增加，从而使得查找、插入和删除操作的时间复杂度从理想的O(log n)退化到O(n)。

## 📌 AVL 树 ----- 为了解决搜索二叉树存在的问题

 二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查
找元素相当于在顺序表中搜索元素，效率低下。因此，两位俄罗斯的数学家G.M.Adelson-Velskii
和E.M.Landis在1962年发明了一种解决上述问题的方法：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右子树高度之差的绝对值不超过1(需要对树中的结点进行调整)，即可降低树的高度，从而减少平均搜索长度。

AVL是他们姓氏的首字母缩写。

### ✏️ 特点

- 要求这棵树的左右高度差(简称平衡因子)不超过 1
 	- 是绝对值不超过 1 [[AVL树#❓ 为什么是不超过 1 呢？]]
- 这棵树的左子树和右子树也都要是 `AVL` 树

❓ 平衡因子是什么：

就是：`右子树的高度 - 左子树的高度`（也有说是左子树的高度 - 右子树的高度的，总之不影响我们使用它的目的）

[这个 up 的视频来了解 avl 树的旋转操作](https://www.bilibili.com/video/BV1tZ421q72h/?spm_id_from=333.337.search-card.all.click&vd_source=fc113385b66ad95c43b04f6e00442a98)

### ❓ 为什么是不超过 1 呢？

AVL 树 叫做高度平衡二叉搜索树，它是通过高度来平衡的，它要求左右子树的高度差不超过 1 ，那为什么是相等呢？ 因为有些数量下我们是做不到左右节点高度差相等的，但是我们可以做到高度差不超过 1

## 📌 实现 AVL 树

### ✏️ AVLTree.h

```c++

template <class K, class V>
struct AVLTreeNote
{
    AVLTreeNote<K, V> *_left;
    AVLTreeNote<K, V> *_right;
    AVLTreeNote<K, V> *_parent;
    pair<K, V> _kv;
    int _bf; // balance factor 平衡因子
};

template <class K, class V>
class AVLTree
{
    typedef AVLTreeNote<K, V> Node; // 这个写起来有点长，我们取个新的名字

public:
    // 插入：
    bool Insert(const pair<K, V> &kv)
    {
        if (_root == nullptr)
        {
            _root = new Node(kv);
            return true;
        }
        else
        {
            Node *parent = nullptr;
            Node *cur = _root;
            while (cur)
            {
                if (cur->_kv.first < key) // 如果要插入的值 key 大于当前节点值的值，我们往右子树走
                {
                    parent = cur;
                    cur = cur->_right;
                }
                else if (cur->_kv.first > key) // 如果要插入的值 key 小于当前节点值 我们就往左子树走
                {
                    parent = cur;
                    cur = cur->_left;
                }
                else // 如果相等就不让插入
                {
                    return false;
                }
            }
            // 当我们把 while 循环走完之后，我们就走到了要插入的地方了
            cur = new Node(kv); // new 一个节点出来
            if (parent->_kv.first < key)
            {
                parent->_right = cur;
                cur->_parent = parent;
            }
            else
            {
                parent->_left = cur;
                cur->_parent = parent;
            }
   // ***************************** 未完 *************
            return ture;
        }
    }

private:
    Node *_root = nullptr; // 定义根节点
};

```

### ✏️ 更新平衡因子的值

❓ 思考，如果我们插入了一个新的节点，那我们该如何来更新平衡因子？

- 父节点的平衡因子应该怎么更新
 如果我插入的是结点`cur` 是插入到父节点的左边的，那么根据平衡因子的公式：`右树高度-左树高度` 此时左树的高度由于我的插入而增加`1` 导致公式的结果会减少 `1`。所以这种情况下父节点的平衡因子应该`-1`
 
 同理：如果我插入的结点在右边，那么插入结点的父节点的平衡因子应该 `+1`
 
- 注意：新增一个结点可能会影响到的是此节点的祖先的平衡因子
 那如何判断这个新增节点会不会影响祖先节点的平衡因子呢？
  - 如果子树的高度变化，就会向上影响祖先的平衡因子
  - 如果子树的高度不变，就不会向上影响祖先的平衡因子
- 新插入的结点的平衡因子 = 0， 因为新插入的结点都是叶子结点
- 总结如下：
 	- 1. 父节点的`bf` (平衡因子）如果在插入结点后变成了 `0`，即：bf == 0，不用继续往上更新了，插入结束。
  		- 原因：插入之后变成 0 了，说明插入之前的 bf = -1 或者 bf = 1，插入的位置刚好把高度低的那棵树补平了，子树的高度没有反生变化所以不会影响到祖先结点
 	- 2. 父节点的平衡因子`bf`，如果在插入之后变成了 `-1, 1`，即 bf == -1 || bf == 1，则要继续往上更新。
  		- 原因：插入之后变成 -1 或者 1， 说明插入之前的 bf == 0 ，即：左右子树的高度是相等的，现在你插入了一个结点，让子树的高度发生了变化，所以会影响祖先结点的平衡因子，所以我们要继续往上更新
 	- 3. 父节点的平衡因子更新后变成了`-2 或者 2`，更加不行，这都违反了AVL树的规则，继续向上跟新

```c
   // 更新平衡因子的值
            while ()
            {
                if (cur == parent->_left) // 插入的节点在左边
                {
                    parent->_bf--;
                }
                else if (cur == parent->_right) // 插入的结点在右边
                {
                    parent->_bf++;
                }
                if (parent->_bf == 0) // 如果父节点的平衡因子== 0，说明插入的结点刚好让左右子树的高度相等了，这种情况下，我们不需要继续向上更新了
                {
                    break; // 不需要更新，直接退出就行了
                }
                else if (parent->_bf == 1 || parent->_bf == -1) // 说明插入节点所在的子树高度变化了，要继续往上更新
                {
                    cur = parent;
                    parent = parent->_parent;
                }
                else // 走到这里说明平衡因子 _bf!= 0 || _bf != 1 ||  _bf != -1, 出问题了,需要旋转治疗一下了。
                {
                    // 旋转
                }
            }
```  

### ✏️  旋转

[这个 up 的视频来了解 avl 树的旋转操作](https://www.bilibili.com/video/BV1tZ421q72h/?spm_id_from=333.337.search-card.all.click&vd_source=fc113385b66ad95c43b04f6e00442a98)

### 🧲 旋转的目的

1. 让左右均衡一些
2. 保持搜索树的规则

### 🧲 旋转代码的实现

#### 📎 插入的结点是 RR 型 - 右（R）子树的右（R）孩子

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/01c75403a1f6446abfb24c9be407b044.png)

##### ==**解决办法** ：左旋==

由图可知，失去平衡节点是节点 5 ，它的`_bf` 已经等于 2 了，不满足条件了，我们的解决办法是将 `结点 5` 向左旋转（逆时针旋转)，让`节点 5`转下来成为 `节点 9`的左孩子，这个时候由于`节点 9` 已经有了左孩子了，所以就冲突了，我们就把冲突的那个`节点 6` 变成`节点 5`的右孩子就可以了，看图：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/949a4839c15f4628a5372102fcc1a5d5.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/881f94a171184a5ba9cb0740ffd43e66.png)

为了便于代码编写，我们给以下节点取个名字：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0846337a71ae4884b5479352a44a2070.png)

按照上面👆🏻的思路我们可以写下如下的代码：

```c++
    void RotateL(Node *parent) // 左单旋转代码,新插入的结点是 RR 型
    {
        Node *subR = parent->_right;
        Node *subRL = subR->_left;

        // 开始旋转,看着图来理解下面的代码，或者自己画一下图
        parent->_right = subRL;
        subR->_left = parent;
    }

```

==但是这样的代码是有问题的：==

1. 根没有处理
2. `parent` 没有处理。（你看结节 6，就是那个`subRL`，它的`parent` 还是指向结点 9 的，但是旋转之后他的 parent 应该是指向结点 5 的）

所以我们要修改一下我们的代码，我们先来理一下各节点的关系：
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/aeac2de93aec4cffbc907be54e909a0d.png)

###### ==处理`parent`:==

旋转之后我们发现节点之间的父子关系发生了变化
节点 5（parent）的父亲变成了 结点 9（subR）

```c++
parent->_parent = subR;
```

节点 6 （subRL）的父亲变成了节点 5 （parent）

```c++
subRL->_parent = parent; 
```

**💥 注意：这里还有一个容易被忽略的问题：节点 6 （subRL）可能是一个空节点**，如何来应对这种情况？
所以我们在把节点 6 的父节点变成节点 5 之前要先做一个判断：

```c++
if (subRL) // 只有节点 6 不为空才能这样。
{
 subRL->_parent = parent;
}
```

###### ==处理根：==

这个时候，subR(节点 9) 成为了这棵树的根节点，但是它的 父节点还是指向节点 5 的，我们要更新一下他的父节点，但是我们首先要弄明白一件事：那就是我们现在看到的这棵树，有可能就这么大了，节点 9 就是这整棵树的根，但是还有一种可能，我们看到的这棵树只是另一棵更大的树的一个局部，节点 9 的上面还有父结点。所以我们要综合的考虑这两种情况。

1. 情况 1 ，节点 9 就是这整棵树的根节点了

```c++
if (_root == parent)
{
 _root = subR; // 把 subR 更新为最新的根节点
 subR->parent = nullptr; // 由于 subR 是这棵树的根节点了，所以它的父节点是空
}
```

2. 情况 2，节点 9 的上面还有父节点,我们假设叫他父节点的父节点即：parentParent，我们在改变 parent这个节点的指向之前要提前把它的父节点给记录📝下来并存放到 parentParent 这个节点中：``Node* parentParent = parent->_parent;``
 这个时候又要分 2 种情况，我们只知道节点 9 上面还有节点，但是这个节点 9 是它父节点的左孩子还是右孩子呢？着我们不清楚，所以我们也要分情况讨论

```c++
else 
{
 // 此节点是其父节点的左孩子
 if (parentParent->_left == parent)
 {
  parentParent->_left = subR;
 }
 // 此节点是其父节点的右孩子
 else
 {
  parentParent->_right = subR;
 }
 // 最后不要忘了，把新的根节点的父节点给链接上去
 subR->_parent = parentParent;
}
```

本步骤完整代码展示：

```c

void RotateL(Node *parent) // 左单旋转代码,新插入的结点是 RR 型
    {
        Node *subR = parent->_right;
        Node *subRL = subR->_left;
        Node *parentParent = parent->_parent; // 把它的父节点先记录下来
        // 开始旋转,看着图来理解下面的代码，或者自己画一下图
        parent->_right = subRL;
        subR->_left = parent;
        // 处理parent
        parent->_parent = subR;
        if (subRL) // subRL 不是空指针才行
        {
            subRL->_parent = parent;
        }

        // 处理根
        if (_root == parent)
        {
            _root = subR;
            subR->_parent = nullptr;
        }
        else 
        {    
            if (parentParent->_left == parent)
            {
                parentParent->_left = subR;
            }
            else if (parentParent->_right == parent)
            {
                parentParent->_right = subR;
            }
            subR->_parent = parentParent;
        }
    }

```

###### ==最后一个步骤更新平衡因子==

到这一步的时候我们的左旋已经结束了，平衡因子也应该做适当的更新，我们可以观察图形：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/aeac2de93aec4cffbc907be54e909a0d.png)

通过图形我们可以知道，`subR` 和`parent` 的平衡因子都变成了 0 ，所以我们的代码如下：

```c
parent->_bf = subR->_bf = 0;
```

#### 📎 插入的结点是 LL 型 - 左（L）子树的左（L）孩子

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a272625d7fd343c7b28436a3ca36e867.png)

我们观察插入节点前后的变化：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/84afa1a06e124d93b796a5e3d54a7b0a.png)

##### ==解决办法：右旋==

观察图形我们可以知道，失去平衡的结点是**14** ，它的平衡因子由-1 变成了 -2，我们想到的办法是让 14 这个结点向右旋转（即：顺时针旋转），让 14 这个节点转下来，让 14 这个节点成为节点 6 的右孩子，但是节点 6 之前就已经有了右孩子 9，这个时候就冲突了，我们的做法是让节点 9 成为节点 14 的左孩子。如图：

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a8a8540dcf474c96a79d503c50dcaee0.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7beaf8a9a1e44d2883a429c797399ba9.png)
